// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	context "context"
	io "io"
	entity "oss-backend/internal/model/entity"

	mock "github.com/stretchr/testify/mock"

	multipart "mime/multipart"
)

// FileService is an autogenerated mock type for the FileService type
type FileService struct {
	mock.Mock
}

type FileService_Expecter struct {
	mock *mock.Mock
}

func (_m *FileService) EXPECT() *FileService_Expecter {
	return &FileService_Expecter{mock: &_m.Mock}
}

// CheckFilePermission provides a mock function with given fields: ctx, fileID, userID, requiredAction
func (_m *FileService) CheckFilePermission(ctx context.Context, fileID string, userID string, requiredAction string) (bool, error) {
	ret := _m.Called(ctx, fileID, userID, requiredAction)

	if len(ret) == 0 {
		panic("no return value specified for CheckFilePermission")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (bool, error)); ok {
		return rf(ctx, fileID, userID, requiredAction)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) bool); ok {
		r0 = rf(ctx, fileID, userID, requiredAction)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, fileID, userID, requiredAction)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileService_CheckFilePermission_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckFilePermission'
type FileService_CheckFilePermission_Call struct {
	*mock.Call
}

// CheckFilePermission is a helper method to define mock.On call
//   - ctx context.Context
//   - fileID string
//   - userID string
//   - requiredAction string
func (_e *FileService_Expecter) CheckFilePermission(ctx interface{}, fileID interface{}, userID interface{}, requiredAction interface{}) *FileService_CheckFilePermission_Call {
	return &FileService_CheckFilePermission_Call{Call: _e.mock.On("CheckFilePermission", ctx, fileID, userID, requiredAction)}
}

func (_c *FileService_CheckFilePermission_Call) Run(run func(ctx context.Context, fileID string, userID string, requiredAction string)) *FileService_CheckFilePermission_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *FileService_CheckFilePermission_Call) Return(_a0 bool, _a1 error) *FileService_CheckFilePermission_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FileService_CheckFilePermission_Call) RunAndReturn(run func(context.Context, string, string, string) (bool, error)) *FileService_CheckFilePermission_Call {
	_c.Call.Return(run)
	return _c
}

// CreateFolder provides a mock function with given fields: ctx, projectID, userID, path, folderName
func (_m *FileService) CreateFolder(ctx context.Context, projectID string, userID string, path string, folderName string) (*entity.File, error) {
	ret := _m.Called(ctx, projectID, userID, path, folderName)

	if len(ret) == 0 {
		panic("no return value specified for CreateFolder")
	}

	var r0 *entity.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) (*entity.File, error)); ok {
		return rf(ctx, projectID, userID, path, folderName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *entity.File); ok {
		r0 = rf(ctx, projectID, userID, path, folderName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, projectID, userID, path, folderName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileService_CreateFolder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateFolder'
type FileService_CreateFolder_Call struct {
	*mock.Call
}

// CreateFolder is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - userID string
//   - path string
//   - folderName string
func (_e *FileService_Expecter) CreateFolder(ctx interface{}, projectID interface{}, userID interface{}, path interface{}, folderName interface{}) *FileService_CreateFolder_Call {
	return &FileService_CreateFolder_Call{Call: _e.mock.On("CreateFolder", ctx, projectID, userID, path, folderName)}
}

func (_c *FileService_CreateFolder_Call) Run(run func(ctx context.Context, projectID string, userID string, path string, folderName string)) *FileService_CreateFolder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string))
	})
	return _c
}

func (_c *FileService_CreateFolder_Call) Return(_a0 *entity.File, _a1 error) *FileService_CreateFolder_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FileService_CreateFolder_Call) RunAndReturn(run func(context.Context, string, string, string, string) (*entity.File, error)) *FileService_CreateFolder_Call {
	_c.Call.Return(run)
	return _c
}

// CreateShare provides a mock function with given fields: ctx, fileID, userID, password, expireHours, downloadLimit
func (_m *FileService) CreateShare(ctx context.Context, fileID string, userID string, password string, expireHours int, downloadLimit int) (*entity.FileShare, error) {
	ret := _m.Called(ctx, fileID, userID, password, expireHours, downloadLimit)

	if len(ret) == 0 {
		panic("no return value specified for CreateShare")
	}

	var r0 *entity.FileShare
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, int) (*entity.FileShare, error)); ok {
		return rf(ctx, fileID, userID, password, expireHours, downloadLimit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, int) *entity.FileShare); ok {
		r0 = rf(ctx, fileID, userID, password, expireHours, downloadLimit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.FileShare)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, int, int) error); ok {
		r1 = rf(ctx, fileID, userID, password, expireHours, downloadLimit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileService_CreateShare_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateShare'
type FileService_CreateShare_Call struct {
	*mock.Call
}

// CreateShare is a helper method to define mock.On call
//   - ctx context.Context
//   - fileID string
//   - userID string
//   - password string
//   - expireHours int
//   - downloadLimit int
func (_e *FileService_Expecter) CreateShare(ctx interface{}, fileID interface{}, userID interface{}, password interface{}, expireHours interface{}, downloadLimit interface{}) *FileService_CreateShare_Call {
	return &FileService_CreateShare_Call{Call: _e.mock.On("CreateShare", ctx, fileID, userID, password, expireHours, downloadLimit)}
}

func (_c *FileService_CreateShare_Call) Run(run func(ctx context.Context, fileID string, userID string, password string, expireHours int, downloadLimit int)) *FileService_CreateShare_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int), args[5].(int))
	})
	return _c
}

func (_c *FileService_CreateShare_Call) Return(_a0 *entity.FileShare, _a1 error) *FileService_CreateShare_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FileService_CreateShare_Call) RunAndReturn(run func(context.Context, string, string, string, int, int) (*entity.FileShare, error)) *FileService_CreateShare_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteFile provides a mock function with given fields: ctx, fileID, userID
func (_m *FileService) DeleteFile(ctx context.Context, fileID string, userID string) error {
	ret := _m.Called(ctx, fileID, userID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, fileID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FileService_DeleteFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteFile'
type FileService_DeleteFile_Call struct {
	*mock.Call
}

// DeleteFile is a helper method to define mock.On call
//   - ctx context.Context
//   - fileID string
//   - userID string
func (_e *FileService_Expecter) DeleteFile(ctx interface{}, fileID interface{}, userID interface{}) *FileService_DeleteFile_Call {
	return &FileService_DeleteFile_Call{Call: _e.mock.On("DeleteFile", ctx, fileID, userID)}
}

func (_c *FileService_DeleteFile_Call) Run(run func(ctx context.Context, fileID string, userID string)) *FileService_DeleteFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *FileService_DeleteFile_Call) Return(_a0 error) *FileService_DeleteFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FileService_DeleteFile_Call) RunAndReturn(run func(context.Context, string, string) error) *FileService_DeleteFile_Call {
	_c.Call.Return(run)
	return _c
}

// Download provides a mock function with given fields: ctx, fileID, userID
func (_m *FileService) Download(ctx context.Context, fileID string, userID string) (io.ReadCloser, *entity.File, error) {
	ret := _m.Called(ctx, fileID, userID)

	if len(ret) == 0 {
		panic("no return value specified for Download")
	}

	var r0 io.ReadCloser
	var r1 *entity.File
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (io.ReadCloser, *entity.File, error)); ok {
		return rf(ctx, fileID, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) io.ReadCloser); ok {
		r0 = rf(ctx, fileID, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) *entity.File); ok {
		r1 = rf(ctx, fileID, userID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*entity.File)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string) error); ok {
		r2 = rf(ctx, fileID, userID)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FileService_Download_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Download'
type FileService_Download_Call struct {
	*mock.Call
}

// Download is a helper method to define mock.On call
//   - ctx context.Context
//   - fileID string
//   - userID string
func (_e *FileService_Expecter) Download(ctx interface{}, fileID interface{}, userID interface{}) *FileService_Download_Call {
	return &FileService_Download_Call{Call: _e.mock.On("Download", ctx, fileID, userID)}
}

func (_c *FileService_Download_Call) Run(run func(ctx context.Context, fileID string, userID string)) *FileService_Download_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *FileService_Download_Call) Return(_a0 io.ReadCloser, _a1 *entity.File, _a2 error) *FileService_Download_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *FileService_Download_Call) RunAndReturn(run func(context.Context, string, string) (io.ReadCloser, *entity.File, error)) *FileService_Download_Call {
	_c.Call.Return(run)
	return _c
}

// DownloadSharedFile provides a mock function with given fields: ctx, shareCode, password
func (_m *FileService) DownloadSharedFile(ctx context.Context, shareCode string, password string) (io.ReadCloser, *entity.File, error) {
	ret := _m.Called(ctx, shareCode, password)

	if len(ret) == 0 {
		panic("no return value specified for DownloadSharedFile")
	}

	var r0 io.ReadCloser
	var r1 *entity.File
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (io.ReadCloser, *entity.File, error)); ok {
		return rf(ctx, shareCode, password)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) io.ReadCloser); ok {
		r0 = rf(ctx, shareCode, password)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) *entity.File); ok {
		r1 = rf(ctx, shareCode, password)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*entity.File)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string) error); ok {
		r2 = rf(ctx, shareCode, password)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FileService_DownloadSharedFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DownloadSharedFile'
type FileService_DownloadSharedFile_Call struct {
	*mock.Call
}

// DownloadSharedFile is a helper method to define mock.On call
//   - ctx context.Context
//   - shareCode string
//   - password string
func (_e *FileService_Expecter) DownloadSharedFile(ctx interface{}, shareCode interface{}, password interface{}) *FileService_DownloadSharedFile_Call {
	return &FileService_DownloadSharedFile_Call{Call: _e.mock.On("DownloadSharedFile", ctx, shareCode, password)}
}

func (_c *FileService_DownloadSharedFile_Call) Run(run func(ctx context.Context, shareCode string, password string)) *FileService_DownloadSharedFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *FileService_DownloadSharedFile_Call) Return(_a0 io.ReadCloser, _a1 *entity.File, _a2 error) *FileService_DownloadSharedFile_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *FileService_DownloadSharedFile_Call) RunAndReturn(run func(context.Context, string, string) (io.ReadCloser, *entity.File, error)) *FileService_DownloadSharedFile_Call {
	_c.Call.Return(run)
	return _c
}

// GetFileInfo provides a mock function with given fields: ctx, fileID
func (_m *FileService) GetFileInfo(ctx context.Context, fileID string) (*entity.File, error) {
	ret := _m.Called(ctx, fileID)

	if len(ret) == 0 {
		panic("no return value specified for GetFileInfo")
	}

	var r0 *entity.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.File, error)); ok {
		return rf(ctx, fileID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.File); ok {
		r0 = rf(ctx, fileID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, fileID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileService_GetFileInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFileInfo'
type FileService_GetFileInfo_Call struct {
	*mock.Call
}

// GetFileInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - fileID string
func (_e *FileService_Expecter) GetFileInfo(ctx interface{}, fileID interface{}) *FileService_GetFileInfo_Call {
	return &FileService_GetFileInfo_Call{Call: _e.mock.On("GetFileInfo", ctx, fileID)}
}

func (_c *FileService_GetFileInfo_Call) Run(run func(ctx context.Context, fileID string)) *FileService_GetFileInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FileService_GetFileInfo_Call) Return(_a0 *entity.File, _a1 error) *FileService_GetFileInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FileService_GetFileInfo_Call) RunAndReturn(run func(context.Context, string) (*entity.File, error)) *FileService_GetFileInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetFileVersion provides a mock function with given fields: ctx, fileID, version
func (_m *FileService) GetFileVersion(ctx context.Context, fileID string, version int) (*entity.FileVersion, error) {
	ret := _m.Called(ctx, fileID, version)

	if len(ret) == 0 {
		panic("no return value specified for GetFileVersion")
	}

	var r0 *entity.FileVersion
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int) (*entity.FileVersion, error)); ok {
		return rf(ctx, fileID, version)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *entity.FileVersion); ok {
		r0 = rf(ctx, fileID, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.FileVersion)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int) error); ok {
		r1 = rf(ctx, fileID, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileService_GetFileVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFileVersion'
type FileService_GetFileVersion_Call struct {
	*mock.Call
}

// GetFileVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - fileID string
//   - version int
func (_e *FileService_Expecter) GetFileVersion(ctx interface{}, fileID interface{}, version interface{}) *FileService_GetFileVersion_Call {
	return &FileService_GetFileVersion_Call{Call: _e.mock.On("GetFileVersion", ctx, fileID, version)}
}

func (_c *FileService_GetFileVersion_Call) Run(run func(ctx context.Context, fileID string, version int)) *FileService_GetFileVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *FileService_GetFileVersion_Call) Return(_a0 *entity.FileVersion, _a1 error) *FileService_GetFileVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FileService_GetFileVersion_Call) RunAndReturn(run func(context.Context, string, int) (*entity.FileVersion, error)) *FileService_GetFileVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetFileVersions provides a mock function with given fields: ctx, fileID
func (_m *FileService) GetFileVersions(ctx context.Context, fileID string) ([]*entity.FileVersion, error) {
	ret := _m.Called(ctx, fileID)

	if len(ret) == 0 {
		panic("no return value specified for GetFileVersions")
	}

	var r0 []*entity.FileVersion
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*entity.FileVersion, error)); ok {
		return rf(ctx, fileID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*entity.FileVersion); ok {
		r0 = rf(ctx, fileID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.FileVersion)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, fileID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileService_GetFileVersions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFileVersions'
type FileService_GetFileVersions_Call struct {
	*mock.Call
}

// GetFileVersions is a helper method to define mock.On call
//   - ctx context.Context
//   - fileID string
func (_e *FileService_Expecter) GetFileVersions(ctx interface{}, fileID interface{}) *FileService_GetFileVersions_Call {
	return &FileService_GetFileVersions_Call{Call: _e.mock.On("GetFileVersions", ctx, fileID)}
}

func (_c *FileService_GetFileVersions_Call) Run(run func(ctx context.Context, fileID string)) *FileService_GetFileVersions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FileService_GetFileVersions_Call) Return(_a0 []*entity.FileVersion, _a1 error) *FileService_GetFileVersions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FileService_GetFileVersions_Call) RunAndReturn(run func(context.Context, string) ([]*entity.FileVersion, error)) *FileService_GetFileVersions_Call {
	_c.Call.Return(run)
	return _c
}

// GetPublicDownloadURL provides a mock function with given fields: ctx, fileID
func (_m *FileService) GetPublicDownloadURL(ctx context.Context, fileID string) (string, error) {
	ret := _m.Called(ctx, fileID)

	if len(ret) == 0 {
		panic("no return value specified for GetPublicDownloadURL")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, fileID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, fileID)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, fileID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileService_GetPublicDownloadURL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPublicDownloadURL'
type FileService_GetPublicDownloadURL_Call struct {
	*mock.Call
}

// GetPublicDownloadURL is a helper method to define mock.On call
//   - ctx context.Context
//   - fileID string
func (_e *FileService_Expecter) GetPublicDownloadURL(ctx interface{}, fileID interface{}) *FileService_GetPublicDownloadURL_Call {
	return &FileService_GetPublicDownloadURL_Call{Call: _e.mock.On("GetPublicDownloadURL", ctx, fileID)}
}

func (_c *FileService_GetPublicDownloadURL_Call) Run(run func(ctx context.Context, fileID string)) *FileService_GetPublicDownloadURL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FileService_GetPublicDownloadURL_Call) Return(_a0 string, _a1 error) *FileService_GetPublicDownloadURL_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FileService_GetPublicDownloadURL_Call) RunAndReturn(run func(context.Context, string) (string, error)) *FileService_GetPublicDownloadURL_Call {
	_c.Call.Return(run)
	return _c
}

// GetShareInfo provides a mock function with given fields: ctx, shareCode
func (_m *FileService) GetShareInfo(ctx context.Context, shareCode string) (*entity.FileShare, error) {
	ret := _m.Called(ctx, shareCode)

	if len(ret) == 0 {
		panic("no return value specified for GetShareInfo")
	}

	var r0 *entity.FileShare
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.FileShare, error)); ok {
		return rf(ctx, shareCode)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.FileShare); ok {
		r0 = rf(ctx, shareCode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.FileShare)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, shareCode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileService_GetShareInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetShareInfo'
type FileService_GetShareInfo_Call struct {
	*mock.Call
}

// GetShareInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - shareCode string
func (_e *FileService_Expecter) GetShareInfo(ctx interface{}, shareCode interface{}) *FileService_GetShareInfo_Call {
	return &FileService_GetShareInfo_Call{Call: _e.mock.On("GetShareInfo", ctx, shareCode)}
}

func (_c *FileService_GetShareInfo_Call) Run(run func(ctx context.Context, shareCode string)) *FileService_GetShareInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FileService_GetShareInfo_Call) Return(_a0 *entity.FileShare, _a1 error) *FileService_GetShareInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FileService_GetShareInfo_Call) RunAndReturn(run func(context.Context, string) (*entity.FileShare, error)) *FileService_GetShareInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ListFiles provides a mock function with given fields: ctx, projectID, path, recursive, page, pageSize
func (_m *FileService) ListFiles(ctx context.Context, projectID string, path string, recursive bool, page int, pageSize int) ([]*entity.File, int64, error) {
	ret := _m.Called(ctx, projectID, path, recursive, page, pageSize)

	if len(ret) == 0 {
		panic("no return value specified for ListFiles")
	}

	var r0 []*entity.File
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, int, int) ([]*entity.File, int64, error)); ok {
		return rf(ctx, projectID, path, recursive, page, pageSize)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, int, int) []*entity.File); ok {
		r0 = rf(ctx, projectID, path, recursive, page, pageSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool, int, int) int64); ok {
		r1 = rf(ctx, projectID, path, recursive, page, pageSize)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool, int, int) error); ok {
		r2 = rf(ctx, projectID, path, recursive, page, pageSize)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FileService_ListFiles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListFiles'
type FileService_ListFiles_Call struct {
	*mock.Call
}

// ListFiles is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - path string
//   - recursive bool
//   - page int
//   - pageSize int
func (_e *FileService_Expecter) ListFiles(ctx interface{}, projectID interface{}, path interface{}, recursive interface{}, page interface{}, pageSize interface{}) *FileService_ListFiles_Call {
	return &FileService_ListFiles_Call{Call: _e.mock.On("ListFiles", ctx, projectID, path, recursive, page, pageSize)}
}

func (_c *FileService_ListFiles_Call) Run(run func(ctx context.Context, projectID string, path string, recursive bool, page int, pageSize int)) *FileService_ListFiles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool), args[4].(int), args[5].(int))
	})
	return _c
}

func (_c *FileService_ListFiles_Call) Return(_a0 []*entity.File, _a1 int64, _a2 error) *FileService_ListFiles_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *FileService_ListFiles_Call) RunAndReturn(run func(context.Context, string, string, bool, int, int) ([]*entity.File, int64, error)) *FileService_ListFiles_Call {
	_c.Call.Return(run)
	return _c
}

// RestoreFile provides a mock function with given fields: ctx, fileID, userID
func (_m *FileService) RestoreFile(ctx context.Context, fileID string, userID string) error {
	ret := _m.Called(ctx, fileID, userID)

	if len(ret) == 0 {
		panic("no return value specified for RestoreFile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, fileID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FileService_RestoreFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreFile'
type FileService_RestoreFile_Call struct {
	*mock.Call
}

// RestoreFile is a helper method to define mock.On call
//   - ctx context.Context
//   - fileID string
//   - userID string
func (_e *FileService_Expecter) RestoreFile(ctx interface{}, fileID interface{}, userID interface{}) *FileService_RestoreFile_Call {
	return &FileService_RestoreFile_Call{Call: _e.mock.On("RestoreFile", ctx, fileID, userID)}
}

func (_c *FileService_RestoreFile_Call) Run(run func(ctx context.Context, fileID string, userID string)) *FileService_RestoreFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *FileService_RestoreFile_Call) Return(_a0 error) *FileService_RestoreFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FileService_RestoreFile_Call) RunAndReturn(run func(context.Context, string, string) error) *FileService_RestoreFile_Call {
	_c.Call.Return(run)
	return _c
}

// Upload provides a mock function with given fields: ctx, projectID, uploaderID, file, path
func (_m *FileService) Upload(ctx context.Context, projectID string, uploaderID string, file *multipart.FileHeader, path string) (*entity.File, error) {
	ret := _m.Called(ctx, projectID, uploaderID, file, path)

	if len(ret) == 0 {
		panic("no return value specified for Upload")
	}

	var r0 *entity.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *multipart.FileHeader, string) (*entity.File, error)); ok {
		return rf(ctx, projectID, uploaderID, file, path)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *multipart.FileHeader, string) *entity.File); ok {
		r0 = rf(ctx, projectID, uploaderID, file, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *multipart.FileHeader, string) error); ok {
		r1 = rf(ctx, projectID, uploaderID, file, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileService_Upload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Upload'
type FileService_Upload_Call struct {
	*mock.Call
}

// Upload is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - uploaderID string
//   - file *multipart.FileHeader
//   - path string
func (_e *FileService_Expecter) Upload(ctx interface{}, projectID interface{}, uploaderID interface{}, file interface{}, path interface{}) *FileService_Upload_Call {
	return &FileService_Upload_Call{Call: _e.mock.On("Upload", ctx, projectID, uploaderID, file, path)}
}

func (_c *FileService_Upload_Call) Run(run func(ctx context.Context, projectID string, uploaderID string, file *multipart.FileHeader, path string)) *FileService_Upload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*multipart.FileHeader), args[4].(string))
	})
	return _c
}

func (_c *FileService_Upload_Call) Return(_a0 *entity.File, _a1 error) *FileService_Upload_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FileService_Upload_Call) RunAndReturn(run func(context.Context, string, string, *multipart.FileHeader, string) (*entity.File, error)) *FileService_Upload_Call {
	_c.Call.Return(run)
	return _c
}

// NewFileService creates a new instance of FileService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFileService(t interface {
	mock.TestingT
	Cleanup(func())
}) *FileService {
	mock := &FileService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
