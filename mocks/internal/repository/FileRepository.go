// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	context "context"
	entity "oss-backend/internal/model/entity"

	mock "github.com/stretchr/testify/mock"
)

// FileRepository is an autogenerated mock type for the FileRepository type
type FileRepository struct {
	mock.Mock
}

type FileRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *FileRepository) EXPECT() *FileRepository_Expecter {
	return &FileRepository_Expecter{mock: &_m.Mock}
}

// Create provides a mock function with given fields: ctx, file
func (_m *FileRepository) Create(ctx context.Context, file *entity.File) error {
	ret := _m.Called(ctx, file)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *entity.File) error); ok {
		r0 = rf(ctx, file)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FileRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type FileRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - file *entity.File
func (_e *FileRepository_Expecter) Create(ctx interface{}, file interface{}) *FileRepository_Create_Call {
	return &FileRepository_Create_Call{Call: _e.mock.On("Create", ctx, file)}
}

func (_c *FileRepository_Create_Call) Run(run func(ctx context.Context, file *entity.File)) *FileRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*entity.File))
	})
	return _c
}

func (_c *FileRepository_Create_Call) Return(_a0 error) *FileRepository_Create_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FileRepository_Create_Call) RunAndReturn(run func(context.Context, *entity.File) error) *FileRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// CreateShare provides a mock function with given fields: ctx, share
func (_m *FileRepository) CreateShare(ctx context.Context, share *entity.FileShare) error {
	ret := _m.Called(ctx, share)

	if len(ret) == 0 {
		panic("no return value specified for CreateShare")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *entity.FileShare) error); ok {
		r0 = rf(ctx, share)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FileRepository_CreateShare_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateShare'
type FileRepository_CreateShare_Call struct {
	*mock.Call
}

// CreateShare is a helper method to define mock.On call
//   - ctx context.Context
//   - share *entity.FileShare
func (_e *FileRepository_Expecter) CreateShare(ctx interface{}, share interface{}) *FileRepository_CreateShare_Call {
	return &FileRepository_CreateShare_Call{Call: _e.mock.On("CreateShare", ctx, share)}
}

func (_c *FileRepository_CreateShare_Call) Run(run func(ctx context.Context, share *entity.FileShare)) *FileRepository_CreateShare_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*entity.FileShare))
	})
	return _c
}

func (_c *FileRepository_CreateShare_Call) Return(_a0 error) *FileRepository_CreateShare_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FileRepository_CreateShare_Call) RunAndReturn(run func(context.Context, *entity.FileShare) error) *FileRepository_CreateShare_Call {
	_c.Call.Return(run)
	return _c
}

// CreateVersion provides a mock function with given fields: ctx, version
func (_m *FileRepository) CreateVersion(ctx context.Context, version *entity.FileVersion) error {
	ret := _m.Called(ctx, version)

	if len(ret) == 0 {
		panic("no return value specified for CreateVersion")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *entity.FileVersion) error); ok {
		r0 = rf(ctx, version)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FileRepository_CreateVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateVersion'
type FileRepository_CreateVersion_Call struct {
	*mock.Call
}

// CreateVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - version *entity.FileVersion
func (_e *FileRepository_Expecter) CreateVersion(ctx interface{}, version interface{}) *FileRepository_CreateVersion_Call {
	return &FileRepository_CreateVersion_Call{Call: _e.mock.On("CreateVersion", ctx, version)}
}

func (_c *FileRepository_CreateVersion_Call) Run(run func(ctx context.Context, version *entity.FileVersion)) *FileRepository_CreateVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*entity.FileVersion))
	})
	return _c
}

func (_c *FileRepository_CreateVersion_Call) Return(_a0 error) *FileRepository_CreateVersion_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FileRepository_CreateVersion_Call) RunAndReturn(run func(context.Context, *entity.FileVersion) error) *FileRepository_CreateVersion_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: ctx, id
func (_m *FileRepository) Delete(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FileRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type FileRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *FileRepository_Expecter) Delete(ctx interface{}, id interface{}) *FileRepository_Delete_Call {
	return &FileRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *FileRepository_Delete_Call) Run(run func(ctx context.Context, id string)) *FileRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FileRepository_Delete_Call) Return(_a0 error) *FileRepository_Delete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FileRepository_Delete_Call) RunAndReturn(run func(context.Context, string) error) *FileRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteShare provides a mock function with given fields: ctx, id
func (_m *FileRepository) DeleteShare(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteShare")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FileRepository_DeleteShare_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteShare'
type FileRepository_DeleteShare_Call struct {
	*mock.Call
}

// DeleteShare is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *FileRepository_Expecter) DeleteShare(ctx interface{}, id interface{}) *FileRepository_DeleteShare_Call {
	return &FileRepository_DeleteShare_Call{Call: _e.mock.On("DeleteShare", ctx, id)}
}

func (_c *FileRepository_DeleteShare_Call) Run(run func(ctx context.Context, id string)) *FileRepository_DeleteShare_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FileRepository_DeleteShare_Call) Return(_a0 error) *FileRepository_DeleteShare_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FileRepository_DeleteShare_Call) RunAndReturn(run func(context.Context, string) error) *FileRepository_DeleteShare_Call {
	_c.Call.Return(run)
	return _c
}

// GetByHash provides a mock function with given fields: ctx, hash
func (_m *FileRepository) GetByHash(ctx context.Context, hash string) (*entity.File, error) {
	ret := _m.Called(ctx, hash)

	if len(ret) == 0 {
		panic("no return value specified for GetByHash")
	}

	var r0 *entity.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.File, error)); ok {
		return rf(ctx, hash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.File); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileRepository_GetByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByHash'
type FileRepository_GetByHash_Call struct {
	*mock.Call
}

// GetByHash is a helper method to define mock.On call
//   - ctx context.Context
//   - hash string
func (_e *FileRepository_Expecter) GetByHash(ctx interface{}, hash interface{}) *FileRepository_GetByHash_Call {
	return &FileRepository_GetByHash_Call{Call: _e.mock.On("GetByHash", ctx, hash)}
}

func (_c *FileRepository_GetByHash_Call) Run(run func(ctx context.Context, hash string)) *FileRepository_GetByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FileRepository_GetByHash_Call) Return(_a0 *entity.File, _a1 error) *FileRepository_GetByHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FileRepository_GetByHash_Call) RunAndReturn(run func(context.Context, string) (*entity.File, error)) *FileRepository_GetByHash_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function with given fields: ctx, id
func (_m *FileRepository) GetByID(ctx context.Context, id string) (*entity.File, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 *entity.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.File, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.File); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type FileRepository_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *FileRepository_Expecter) GetByID(ctx interface{}, id interface{}) *FileRepository_GetByID_Call {
	return &FileRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}

func (_c *FileRepository_GetByID_Call) Run(run func(ctx context.Context, id string)) *FileRepository_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FileRepository_GetByID_Call) Return(_a0 *entity.File, _a1 error) *FileRepository_GetByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FileRepository_GetByID_Call) RunAndReturn(run func(context.Context, string) (*entity.File, error)) *FileRepository_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetByPath provides a mock function with given fields: ctx, projectID, path, fileName
func (_m *FileRepository) GetByPath(ctx context.Context, projectID string, path string, fileName string) (*entity.File, error) {
	ret := _m.Called(ctx, projectID, path, fileName)

	if len(ret) == 0 {
		panic("no return value specified for GetByPath")
	}

	var r0 *entity.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (*entity.File, error)); ok {
		return rf(ctx, projectID, path, fileName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *entity.File); ok {
		r0 = rf(ctx, projectID, path, fileName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, projectID, path, fileName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileRepository_GetByPath_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByPath'
type FileRepository_GetByPath_Call struct {
	*mock.Call
}

// GetByPath is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - path string
//   - fileName string
func (_e *FileRepository_Expecter) GetByPath(ctx interface{}, projectID interface{}, path interface{}, fileName interface{}) *FileRepository_GetByPath_Call {
	return &FileRepository_GetByPath_Call{Call: _e.mock.On("GetByPath", ctx, projectID, path, fileName)}
}

func (_c *FileRepository_GetByPath_Call) Run(run func(ctx context.Context, projectID string, path string, fileName string)) *FileRepository_GetByPath_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *FileRepository_GetByPath_Call) Return(_a0 *entity.File, _a1 error) *FileRepository_GetByPath_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FileRepository_GetByPath_Call) RunAndReturn(run func(context.Context, string, string, string) (*entity.File, error)) *FileRepository_GetByPath_Call {
	_c.Call.Return(run)
	return _c
}

// GetShareByCode provides a mock function with given fields: ctx, code
func (_m *FileRepository) GetShareByCode(ctx context.Context, code string) (*entity.FileShare, error) {
	ret := _m.Called(ctx, code)

	if len(ret) == 0 {
		panic("no return value specified for GetShareByCode")
	}

	var r0 *entity.FileShare
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.FileShare, error)); ok {
		return rf(ctx, code)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.FileShare); ok {
		r0 = rf(ctx, code)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.FileShare)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, code)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileRepository_GetShareByCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetShareByCode'
type FileRepository_GetShareByCode_Call struct {
	*mock.Call
}

// GetShareByCode is a helper method to define mock.On call
//   - ctx context.Context
//   - code string
func (_e *FileRepository_Expecter) GetShareByCode(ctx interface{}, code interface{}) *FileRepository_GetShareByCode_Call {
	return &FileRepository_GetShareByCode_Call{Call: _e.mock.On("GetShareByCode", ctx, code)}
}

func (_c *FileRepository_GetShareByCode_Call) Run(run func(ctx context.Context, code string)) *FileRepository_GetShareByCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FileRepository_GetShareByCode_Call) Return(_a0 *entity.FileShare, _a1 error) *FileRepository_GetShareByCode_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FileRepository_GetShareByCode_Call) RunAndReturn(run func(context.Context, string) (*entity.FileShare, error)) *FileRepository_GetShareByCode_Call {
	_c.Call.Return(run)
	return _c
}

// GetVersionByID provides a mock function with given fields: ctx, fileID, version
func (_m *FileRepository) GetVersionByID(ctx context.Context, fileID string, version int) (*entity.FileVersion, error) {
	ret := _m.Called(ctx, fileID, version)

	if len(ret) == 0 {
		panic("no return value specified for GetVersionByID")
	}

	var r0 *entity.FileVersion
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int) (*entity.FileVersion, error)); ok {
		return rf(ctx, fileID, version)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *entity.FileVersion); ok {
		r0 = rf(ctx, fileID, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.FileVersion)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int) error); ok {
		r1 = rf(ctx, fileID, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileRepository_GetVersionByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVersionByID'
type FileRepository_GetVersionByID_Call struct {
	*mock.Call
}

// GetVersionByID is a helper method to define mock.On call
//   - ctx context.Context
//   - fileID string
//   - version int
func (_e *FileRepository_Expecter) GetVersionByID(ctx interface{}, fileID interface{}, version interface{}) *FileRepository_GetVersionByID_Call {
	return &FileRepository_GetVersionByID_Call{Call: _e.mock.On("GetVersionByID", ctx, fileID, version)}
}

func (_c *FileRepository_GetVersionByID_Call) Run(run func(ctx context.Context, fileID string, version int)) *FileRepository_GetVersionByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *FileRepository_GetVersionByID_Call) Return(_a0 *entity.FileVersion, _a1 error) *FileRepository_GetVersionByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FileRepository_GetVersionByID_Call) RunAndReturn(run func(context.Context, string, int) (*entity.FileVersion, error)) *FileRepository_GetVersionByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetVersions provides a mock function with given fields: ctx, fileID
func (_m *FileRepository) GetVersions(ctx context.Context, fileID string) ([]*entity.FileVersion, error) {
	ret := _m.Called(ctx, fileID)

	if len(ret) == 0 {
		panic("no return value specified for GetVersions")
	}

	var r0 []*entity.FileVersion
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*entity.FileVersion, error)); ok {
		return rf(ctx, fileID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*entity.FileVersion); ok {
		r0 = rf(ctx, fileID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.FileVersion)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, fileID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileRepository_GetVersions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVersions'
type FileRepository_GetVersions_Call struct {
	*mock.Call
}

// GetVersions is a helper method to define mock.On call
//   - ctx context.Context
//   - fileID string
func (_e *FileRepository_Expecter) GetVersions(ctx interface{}, fileID interface{}) *FileRepository_GetVersions_Call {
	return &FileRepository_GetVersions_Call{Call: _e.mock.On("GetVersions", ctx, fileID)}
}

func (_c *FileRepository_GetVersions_Call) Run(run func(ctx context.Context, fileID string)) *FileRepository_GetVersions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FileRepository_GetVersions_Call) Return(_a0 []*entity.FileVersion, _a1 error) *FileRepository_GetVersions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FileRepository_GetVersions_Call) RunAndReturn(run func(context.Context, string) ([]*entity.FileVersion, error)) *FileRepository_GetVersions_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function with given fields: ctx, projectID, path, recursive, includeDeleted, page, pageSize
func (_m *FileRepository) List(ctx context.Context, projectID string, path string, recursive bool, includeDeleted bool, page int, pageSize int) ([]*entity.File, int64, error) {
	ret := _m.Called(ctx, projectID, path, recursive, includeDeleted, page, pageSize)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 []*entity.File
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, bool, int, int) ([]*entity.File, int64, error)); ok {
		return rf(ctx, projectID, path, recursive, includeDeleted, page, pageSize)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, bool, int, int) []*entity.File); ok {
		r0 = rf(ctx, projectID, path, recursive, includeDeleted, page, pageSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool, bool, int, int) int64); ok {
		r1 = rf(ctx, projectID, path, recursive, includeDeleted, page, pageSize)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool, bool, int, int) error); ok {
		r2 = rf(ctx, projectID, path, recursive, includeDeleted, page, pageSize)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FileRepository_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type FileRepository_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - path string
//   - recursive bool
//   - includeDeleted bool
//   - page int
//   - pageSize int
func (_e *FileRepository_Expecter) List(ctx interface{}, projectID interface{}, path interface{}, recursive interface{}, includeDeleted interface{}, page interface{}, pageSize interface{}) *FileRepository_List_Call {
	return &FileRepository_List_Call{Call: _e.mock.On("List", ctx, projectID, path, recursive, includeDeleted, page, pageSize)}
}

func (_c *FileRepository_List_Call) Run(run func(ctx context.Context, projectID string, path string, recursive bool, includeDeleted bool, page int, pageSize int)) *FileRepository_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool), args[4].(bool), args[5].(int), args[6].(int))
	})
	return _c
}

func (_c *FileRepository_List_Call) Return(_a0 []*entity.File, _a1 int64, _a2 error) *FileRepository_List_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *FileRepository_List_Call) RunAndReturn(run func(context.Context, string, string, bool, bool, int, int) ([]*entity.File, int64, error)) *FileRepository_List_Call {
	_c.Call.Return(run)
	return _c
}

// ListByIDs provides a mock function with given fields: ctx, ids
func (_m *FileRepository) ListByIDs(ctx context.Context, ids []string) ([]*entity.File, error) {
	ret := _m.Called(ctx, ids)

	if len(ret) == 0 {
		panic("no return value specified for ListByIDs")
	}

	var r0 []*entity.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*entity.File, error)); ok {
		return rf(ctx, ids)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*entity.File); ok {
		r0 = rf(ctx, ids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, ids)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileRepository_ListByIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListByIDs'
type FileRepository_ListByIDs_Call struct {
	*mock.Call
}

// ListByIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - ids []string
func (_e *FileRepository_Expecter) ListByIDs(ctx interface{}, ids interface{}) *FileRepository_ListByIDs_Call {
	return &FileRepository_ListByIDs_Call{Call: _e.mock.On("ListByIDs", ctx, ids)}
}

func (_c *FileRepository_ListByIDs_Call) Run(run func(ctx context.Context, ids []string)) *FileRepository_ListByIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *FileRepository_ListByIDs_Call) Return(_a0 []*entity.File, _a1 error) *FileRepository_ListByIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FileRepository_ListByIDs_Call) RunAndReturn(run func(context.Context, []string) ([]*entity.File, error)) *FileRepository_ListByIDs_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: ctx, file
func (_m *FileRepository) Update(ctx context.Context, file *entity.File) error {
	ret := _m.Called(ctx, file)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *entity.File) error); ok {
		r0 = rf(ctx, file)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FileRepository_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type FileRepository_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - file *entity.File
func (_e *FileRepository_Expecter) Update(ctx interface{}, file interface{}) *FileRepository_Update_Call {
	return &FileRepository_Update_Call{Call: _e.mock.On("Update", ctx, file)}
}

func (_c *FileRepository_Update_Call) Run(run func(ctx context.Context, file *entity.File)) *FileRepository_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*entity.File))
	})
	return _c
}

func (_c *FileRepository_Update_Call) Return(_a0 error) *FileRepository_Update_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FileRepository_Update_Call) RunAndReturn(run func(context.Context, *entity.File) error) *FileRepository_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateShareDownloadCount provides a mock function with given fields: ctx, shareID
func (_m *FileRepository) UpdateShareDownloadCount(ctx context.Context, shareID string) error {
	ret := _m.Called(ctx, shareID)

	if len(ret) == 0 {
		panic("no return value specified for UpdateShareDownloadCount")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, shareID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FileRepository_UpdateShareDownloadCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateShareDownloadCount'
type FileRepository_UpdateShareDownloadCount_Call struct {
	*mock.Call
}

// UpdateShareDownloadCount is a helper method to define mock.On call
//   - ctx context.Context
//   - shareID string
func (_e *FileRepository_Expecter) UpdateShareDownloadCount(ctx interface{}, shareID interface{}) *FileRepository_UpdateShareDownloadCount_Call {
	return &FileRepository_UpdateShareDownloadCount_Call{Call: _e.mock.On("UpdateShareDownloadCount", ctx, shareID)}
}

func (_c *FileRepository_UpdateShareDownloadCount_Call) Run(run func(ctx context.Context, shareID string)) *FileRepository_UpdateShareDownloadCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *FileRepository_UpdateShareDownloadCount_Call) Return(_a0 error) *FileRepository_UpdateShareDownloadCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FileRepository_UpdateShareDownloadCount_Call) RunAndReturn(run func(context.Context, string) error) *FileRepository_UpdateShareDownloadCount_Call {
	_c.Call.Return(run)
	return _c
}

// NewFileRepository creates a new instance of FileRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFileRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *FileRepository {
	mock := &FileRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
