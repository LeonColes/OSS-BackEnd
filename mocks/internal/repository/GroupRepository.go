// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	context "context"
	dto "oss-backend/internal/model/dto"
	entity "oss-backend/internal/model/entity"

	mock "github.com/stretchr/testify/mock"

	time "time"
)

// GroupRepository is an autogenerated mock type for the GroupRepository type
type GroupRepository struct {
	mock.Mock
}

type GroupRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *GroupRepository) EXPECT() *GroupRepository_Expecter {
	return &GroupRepository_Expecter{mock: &_m.Mock}
}

// AddMember provides a mock function with given fields: ctx, member
func (_m *GroupRepository) AddMember(ctx context.Context, member *entity.GroupMember) error {
	ret := _m.Called(ctx, member)

	if len(ret) == 0 {
		panic("no return value specified for AddMember")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *entity.GroupMember) error); ok {
		r0 = rf(ctx, member)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GroupRepository_AddMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddMember'
type GroupRepository_AddMember_Call struct {
	*mock.Call
}

// AddMember is a helper method to define mock.On call
//   - ctx context.Context
//   - member *entity.GroupMember
func (_e *GroupRepository_Expecter) AddMember(ctx interface{}, member interface{}) *GroupRepository_AddMember_Call {
	return &GroupRepository_AddMember_Call{Call: _e.mock.On("AddMember", ctx, member)}
}

func (_c *GroupRepository_AddMember_Call) Run(run func(ctx context.Context, member *entity.GroupMember)) *GroupRepository_AddMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*entity.GroupMember))
	})
	return _c
}

func (_c *GroupRepository_AddMember_Call) Return(_a0 error) *GroupRepository_AddMember_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *GroupRepository_AddMember_Call) RunAndReturn(run func(context.Context, *entity.GroupMember) error) *GroupRepository_AddMember_Call {
	_c.Call.Return(run)
	return _c
}

// CheckUserGroupRole provides a mock function with given fields: ctx, userID, groupID, role
func (_m *GroupRepository) CheckUserGroupRole(ctx context.Context, userID string, groupID string, role string) (bool, error) {
	ret := _m.Called(ctx, userID, groupID, role)

	if len(ret) == 0 {
		panic("no return value specified for CheckUserGroupRole")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (bool, error)); ok {
		return rf(ctx, userID, groupID, role)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) bool); ok {
		r0 = rf(ctx, userID, groupID, role)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, userID, groupID, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupRepository_CheckUserGroupRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckUserGroupRole'
type GroupRepository_CheckUserGroupRole_Call struct {
	*mock.Call
}

// CheckUserGroupRole is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - groupID string
//   - role string
func (_e *GroupRepository_Expecter) CheckUserGroupRole(ctx interface{}, userID interface{}, groupID interface{}, role interface{}) *GroupRepository_CheckUserGroupRole_Call {
	return &GroupRepository_CheckUserGroupRole_Call{Call: _e.mock.On("CheckUserGroupRole", ctx, userID, groupID, role)}
}

func (_c *GroupRepository_CheckUserGroupRole_Call) Run(run func(ctx context.Context, userID string, groupID string, role string)) *GroupRepository_CheckUserGroupRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *GroupRepository_CheckUserGroupRole_Call) Return(_a0 bool, _a1 error) *GroupRepository_CheckUserGroupRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupRepository_CheckUserGroupRole_Call) RunAndReturn(run func(context.Context, string, string, string) (bool, error)) *GroupRepository_CheckUserGroupRole_Call {
	_c.Call.Return(run)
	return _c
}

// CheckUserInGroup provides a mock function with given fields: ctx, userID, groupID
func (_m *GroupRepository) CheckUserInGroup(ctx context.Context, userID string, groupID string) (bool, error) {
	ret := _m.Called(ctx, userID, groupID)

	if len(ret) == 0 {
		panic("no return value specified for CheckUserInGroup")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return rf(ctx, userID, groupID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = rf(ctx, userID, groupID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, userID, groupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupRepository_CheckUserInGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckUserInGroup'
type GroupRepository_CheckUserInGroup_Call struct {
	*mock.Call
}

// CheckUserInGroup is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - groupID string
func (_e *GroupRepository_Expecter) CheckUserInGroup(ctx interface{}, userID interface{}, groupID interface{}) *GroupRepository_CheckUserInGroup_Call {
	return &GroupRepository_CheckUserInGroup_Call{Call: _e.mock.On("CheckUserInGroup", ctx, userID, groupID)}
}

func (_c *GroupRepository_CheckUserInGroup_Call) Run(run func(ctx context.Context, userID string, groupID string)) *GroupRepository_CheckUserInGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *GroupRepository_CheckUserInGroup_Call) Return(_a0 bool, _a1 error) *GroupRepository_CheckUserInGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupRepository_CheckUserInGroup_Call) RunAndReturn(run func(context.Context, string, string) (bool, error)) *GroupRepository_CheckUserInGroup_Call {
	_c.Call.Return(run)
	return _c
}

// CreateGroup provides a mock function with given fields: ctx, group
func (_m *GroupRepository) CreateGroup(ctx context.Context, group *entity.Group) error {
	ret := _m.Called(ctx, group)

	if len(ret) == 0 {
		panic("no return value specified for CreateGroup")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *entity.Group) error); ok {
		r0 = rf(ctx, group)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GroupRepository_CreateGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateGroup'
type GroupRepository_CreateGroup_Call struct {
	*mock.Call
}

// CreateGroup is a helper method to define mock.On call
//   - ctx context.Context
//   - group *entity.Group
func (_e *GroupRepository_Expecter) CreateGroup(ctx interface{}, group interface{}) *GroupRepository_CreateGroup_Call {
	return &GroupRepository_CreateGroup_Call{Call: _e.mock.On("CreateGroup", ctx, group)}
}

func (_c *GroupRepository_CreateGroup_Call) Run(run func(ctx context.Context, group *entity.Group)) *GroupRepository_CreateGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*entity.Group))
	})
	return _c
}

func (_c *GroupRepository_CreateGroup_Call) Return(_a0 error) *GroupRepository_CreateGroup_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *GroupRepository_CreateGroup_Call) RunAndReturn(run func(context.Context, *entity.Group) error) *GroupRepository_CreateGroup_Call {
	_c.Call.Return(run)
	return _c
}

// GenerateInviteCode provides a mock function with given fields: ctx, groupID, expireDays
func (_m *GroupRepository) GenerateInviteCode(ctx context.Context, groupID string, expireDays int) (string, time.Time, error) {
	ret := _m.Called(ctx, groupID, expireDays)

	if len(ret) == 0 {
		panic("no return value specified for GenerateInviteCode")
	}

	var r0 string
	var r1 time.Time
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int) (string, time.Time, error)); ok {
		return rf(ctx, groupID, expireDays)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int) string); ok {
		r0 = rf(ctx, groupID, expireDays)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int) time.Time); ok {
		r1 = rf(ctx, groupID, expireDays)
	} else {
		r1 = ret.Get(1).(time.Time)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int) error); ok {
		r2 = rf(ctx, groupID, expireDays)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupRepository_GenerateInviteCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateInviteCode'
type GroupRepository_GenerateInviteCode_Call struct {
	*mock.Call
}

// GenerateInviteCode is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID string
//   - expireDays int
func (_e *GroupRepository_Expecter) GenerateInviteCode(ctx interface{}, groupID interface{}, expireDays interface{}) *GroupRepository_GenerateInviteCode_Call {
	return &GroupRepository_GenerateInviteCode_Call{Call: _e.mock.On("GenerateInviteCode", ctx, groupID, expireDays)}
}

func (_c *GroupRepository_GenerateInviteCode_Call) Run(run func(ctx context.Context, groupID string, expireDays int)) *GroupRepository_GenerateInviteCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *GroupRepository_GenerateInviteCode_Call) Return(_a0 string, _a1 time.Time, _a2 error) *GroupRepository_GenerateInviteCode_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupRepository_GenerateInviteCode_Call) RunAndReturn(run func(context.Context, string, int) (string, time.Time, error)) *GroupRepository_GenerateInviteCode_Call {
	_c.Call.Return(run)
	return _c
}

// GetGroupByID provides a mock function with given fields: ctx, id
func (_m *GroupRepository) GetGroupByID(ctx context.Context, id string) (*entity.Group, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetGroupByID")
	}

	var r0 *entity.Group
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.Group, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.Group); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupRepository_GetGroupByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGroupByID'
type GroupRepository_GetGroupByID_Call struct {
	*mock.Call
}

// GetGroupByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *GroupRepository_Expecter) GetGroupByID(ctx interface{}, id interface{}) *GroupRepository_GetGroupByID_Call {
	return &GroupRepository_GetGroupByID_Call{Call: _e.mock.On("GetGroupByID", ctx, id)}
}

func (_c *GroupRepository_GetGroupByID_Call) Run(run func(ctx context.Context, id string)) *GroupRepository_GetGroupByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *GroupRepository_GetGroupByID_Call) Return(_a0 *entity.Group, _a1 error) *GroupRepository_GetGroupByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupRepository_GetGroupByID_Call) RunAndReturn(run func(context.Context, string) (*entity.Group, error)) *GroupRepository_GetGroupByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetGroupByInviteCode provides a mock function with given fields: ctx, code
func (_m *GroupRepository) GetGroupByInviteCode(ctx context.Context, code string) (*entity.Group, error) {
	ret := _m.Called(ctx, code)

	if len(ret) == 0 {
		panic("no return value specified for GetGroupByInviteCode")
	}

	var r0 *entity.Group
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.Group, error)); ok {
		return rf(ctx, code)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.Group); ok {
		r0 = rf(ctx, code)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, code)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupRepository_GetGroupByInviteCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGroupByInviteCode'
type GroupRepository_GetGroupByInviteCode_Call struct {
	*mock.Call
}

// GetGroupByInviteCode is a helper method to define mock.On call
//   - ctx context.Context
//   - code string
func (_e *GroupRepository_Expecter) GetGroupByInviteCode(ctx interface{}, code interface{}) *GroupRepository_GetGroupByInviteCode_Call {
	return &GroupRepository_GetGroupByInviteCode_Call{Call: _e.mock.On("GetGroupByInviteCode", ctx, code)}
}

func (_c *GroupRepository_GetGroupByInviteCode_Call) Run(run func(ctx context.Context, code string)) *GroupRepository_GetGroupByInviteCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *GroupRepository_GetGroupByInviteCode_Call) Return(_a0 *entity.Group, _a1 error) *GroupRepository_GetGroupByInviteCode_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupRepository_GetGroupByInviteCode_Call) RunAndReturn(run func(context.Context, string) (*entity.Group, error)) *GroupRepository_GetGroupByInviteCode_Call {
	_c.Call.Return(run)
	return _c
}

// GetGroupByKey provides a mock function with given fields: ctx, key
func (_m *GroupRepository) GetGroupByKey(ctx context.Context, key string) (*entity.Group, error) {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetGroupByKey")
	}

	var r0 *entity.Group
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.Group, error)); ok {
		return rf(ctx, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.Group); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupRepository_GetGroupByKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGroupByKey'
type GroupRepository_GetGroupByKey_Call struct {
	*mock.Call
}

// GetGroupByKey is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *GroupRepository_Expecter) GetGroupByKey(ctx interface{}, key interface{}) *GroupRepository_GetGroupByKey_Call {
	return &GroupRepository_GetGroupByKey_Call{Call: _e.mock.On("GetGroupByKey", ctx, key)}
}

func (_c *GroupRepository_GetGroupByKey_Call) Run(run func(ctx context.Context, key string)) *GroupRepository_GetGroupByKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *GroupRepository_GetGroupByKey_Call) Return(_a0 *entity.Group, _a1 error) *GroupRepository_GetGroupByKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupRepository_GetGroupByKey_Call) RunAndReturn(run func(context.Context, string) (*entity.Group, error)) *GroupRepository_GetGroupByKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetMember provides a mock function with given fields: ctx, groupID, userID
func (_m *GroupRepository) GetMember(ctx context.Context, groupID string, userID string) (*entity.GroupMember, error) {
	ret := _m.Called(ctx, groupID, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetMember")
	}

	var r0 *entity.GroupMember
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*entity.GroupMember, error)); ok {
		return rf(ctx, groupID, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *entity.GroupMember); ok {
		r0 = rf(ctx, groupID, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.GroupMember)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, groupID, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupRepository_GetMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMember'
type GroupRepository_GetMember_Call struct {
	*mock.Call
}

// GetMember is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID string
//   - userID string
func (_e *GroupRepository_Expecter) GetMember(ctx interface{}, groupID interface{}, userID interface{}) *GroupRepository_GetMember_Call {
	return &GroupRepository_GetMember_Call{Call: _e.mock.On("GetMember", ctx, groupID, userID)}
}

func (_c *GroupRepository_GetMember_Call) Run(run func(ctx context.Context, groupID string, userID string)) *GroupRepository_GetMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *GroupRepository_GetMember_Call) Return(_a0 *entity.GroupMember, _a1 error) *GroupRepository_GetMember_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupRepository_GetMember_Call) RunAndReturn(run func(context.Context, string, string) (*entity.GroupMember, error)) *GroupRepository_GetMember_Call {
	_c.Call.Return(run)
	return _c
}

// GetMemberCount provides a mock function with given fields: ctx, groupID
func (_m *GroupRepository) GetMemberCount(ctx context.Context, groupID string) (int, error) {
	ret := _m.Called(ctx, groupID)

	if len(ret) == 0 {
		panic("no return value specified for GetMemberCount")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (int, error)); ok {
		return rf(ctx, groupID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) int); ok {
		r0 = rf(ctx, groupID)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, groupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupRepository_GetMemberCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMemberCount'
type GroupRepository_GetMemberCount_Call struct {
	*mock.Call
}

// GetMemberCount is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID string
func (_e *GroupRepository_Expecter) GetMemberCount(ctx interface{}, groupID interface{}) *GroupRepository_GetMemberCount_Call {
	return &GroupRepository_GetMemberCount_Call{Call: _e.mock.On("GetMemberCount", ctx, groupID)}
}

func (_c *GroupRepository_GetMemberCount_Call) Run(run func(ctx context.Context, groupID string)) *GroupRepository_GetMemberCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *GroupRepository_GetMemberCount_Call) Return(_a0 int, _a1 error) *GroupRepository_GetMemberCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupRepository_GetMemberCount_Call) RunAndReturn(run func(context.Context, string) (int, error)) *GroupRepository_GetMemberCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetProjectCount provides a mock function with given fields: ctx, groupID
func (_m *GroupRepository) GetProjectCount(ctx context.Context, groupID string) (int, error) {
	ret := _m.Called(ctx, groupID)

	if len(ret) == 0 {
		panic("no return value specified for GetProjectCount")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (int, error)); ok {
		return rf(ctx, groupID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) int); ok {
		r0 = rf(ctx, groupID)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, groupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupRepository_GetProjectCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProjectCount'
type GroupRepository_GetProjectCount_Call struct {
	*mock.Call
}

// GetProjectCount is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID string
func (_e *GroupRepository_Expecter) GetProjectCount(ctx interface{}, groupID interface{}) *GroupRepository_GetProjectCount_Call {
	return &GroupRepository_GetProjectCount_Call{Call: _e.mock.On("GetProjectCount", ctx, groupID)}
}

func (_c *GroupRepository_GetProjectCount_Call) Run(run func(ctx context.Context, groupID string)) *GroupRepository_GetProjectCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *GroupRepository_GetProjectCount_Call) Return(_a0 int, _a1 error) *GroupRepository_GetProjectCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupRepository_GetProjectCount_Call) RunAndReturn(run func(context.Context, string) (int, error)) *GroupRepository_GetProjectCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetStorageUsed provides a mock function with given fields: ctx, groupID
func (_m *GroupRepository) GetStorageUsed(ctx context.Context, groupID string) (int64, error) {
	ret := _m.Called(ctx, groupID)

	if len(ret) == 0 {
		panic("no return value specified for GetStorageUsed")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (int64, error)); ok {
		return rf(ctx, groupID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, groupID)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, groupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupRepository_GetStorageUsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStorageUsed'
type GroupRepository_GetStorageUsed_Call struct {
	*mock.Call
}

// GetStorageUsed is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID string
func (_e *GroupRepository_Expecter) GetStorageUsed(ctx interface{}, groupID interface{}) *GroupRepository_GetStorageUsed_Call {
	return &GroupRepository_GetStorageUsed_Call{Call: _e.mock.On("GetStorageUsed", ctx, groupID)}
}

func (_c *GroupRepository_GetStorageUsed_Call) Run(run func(ctx context.Context, groupID string)) *GroupRepository_GetStorageUsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *GroupRepository_GetStorageUsed_Call) Return(_a0 int64, _a1 error) *GroupRepository_GetStorageUsed_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupRepository_GetStorageUsed_Call) RunAndReturn(run func(context.Context, string) (int64, error)) *GroupRepository_GetStorageUsed_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserGroups provides a mock function with given fields: ctx, userID
func (_m *GroupRepository) GetUserGroups(ctx context.Context, userID string) ([]entity.Group, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserGroups")
	}

	var r0 []entity.Group
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]entity.Group, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []entity.Group); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupRepository_GetUserGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserGroups'
type GroupRepository_GetUserGroups_Call struct {
	*mock.Call
}

// GetUserGroups is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *GroupRepository_Expecter) GetUserGroups(ctx interface{}, userID interface{}) *GroupRepository_GetUserGroups_Call {
	return &GroupRepository_GetUserGroups_Call{Call: _e.mock.On("GetUserGroups", ctx, userID)}
}

func (_c *GroupRepository_GetUserGroups_Call) Run(run func(ctx context.Context, userID string)) *GroupRepository_GetUserGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *GroupRepository_GetUserGroups_Call) Return(_a0 []entity.Group, _a1 error) *GroupRepository_GetUserGroups_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupRepository_GetUserGroups_Call) RunAndReturn(run func(context.Context, string) ([]entity.Group, error)) *GroupRepository_GetUserGroups_Call {
	_c.Call.Return(run)
	return _c
}

// ListGroups provides a mock function with given fields: ctx, req
func (_m *GroupRepository) ListGroups(ctx context.Context, req *dto.GroupListRequest) ([]entity.Group, int64, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for ListGroups")
	}

	var r0 []entity.Group
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *dto.GroupListRequest) ([]entity.Group, int64, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *dto.GroupListRequest) []entity.Group); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *dto.GroupListRequest) int64); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *dto.GroupListRequest) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupRepository_ListGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGroups'
type GroupRepository_ListGroups_Call struct {
	*mock.Call
}

// ListGroups is a helper method to define mock.On call
//   - ctx context.Context
//   - req *dto.GroupListRequest
func (_e *GroupRepository_Expecter) ListGroups(ctx interface{}, req interface{}) *GroupRepository_ListGroups_Call {
	return &GroupRepository_ListGroups_Call{Call: _e.mock.On("ListGroups", ctx, req)}
}

func (_c *GroupRepository_ListGroups_Call) Run(run func(ctx context.Context, req *dto.GroupListRequest)) *GroupRepository_ListGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*dto.GroupListRequest))
	})
	return _c
}

func (_c *GroupRepository_ListGroups_Call) Return(_a0 []entity.Group, _a1 int64, _a2 error) *GroupRepository_ListGroups_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupRepository_ListGroups_Call) RunAndReturn(run func(context.Context, *dto.GroupListRequest) ([]entity.Group, int64, error)) *GroupRepository_ListGroups_Call {
	_c.Call.Return(run)
	return _c
}

// ListMembers provides a mock function with given fields: ctx, groupID, page, size
func (_m *GroupRepository) ListMembers(ctx context.Context, groupID string, page int, size int) ([]entity.GroupMember, int64, error) {
	ret := _m.Called(ctx, groupID, page, size)

	if len(ret) == 0 {
		panic("no return value specified for ListMembers")
	}

	var r0 []entity.GroupMember
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) ([]entity.GroupMember, int64, error)); ok {
		return rf(ctx, groupID, page, size)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) []entity.GroupMember); ok {
		r0 = rf(ctx, groupID, page, size)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.GroupMember)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, int) int64); ok {
		r1 = rf(ctx, groupID, page, size)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, int) error); ok {
		r2 = rf(ctx, groupID, page, size)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupRepository_ListMembers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMembers'
type GroupRepository_ListMembers_Call struct {
	*mock.Call
}

// ListMembers is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID string
//   - page int
//   - size int
func (_e *GroupRepository_Expecter) ListMembers(ctx interface{}, groupID interface{}, page interface{}, size interface{}) *GroupRepository_ListMembers_Call {
	return &GroupRepository_ListMembers_Call{Call: _e.mock.On("ListMembers", ctx, groupID, page, size)}
}

func (_c *GroupRepository_ListMembers_Call) Run(run func(ctx context.Context, groupID string, page int, size int)) *GroupRepository_ListMembers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *GroupRepository_ListMembers_Call) Return(_a0 []entity.GroupMember, _a1 int64, _a2 error) *GroupRepository_ListMembers_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupRepository_ListMembers_Call) RunAndReturn(run func(context.Context, string, int, int) ([]entity.GroupMember, int64, error)) *GroupRepository_ListMembers_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveMember provides a mock function with given fields: ctx, groupID, userID
func (_m *GroupRepository) RemoveMember(ctx context.Context, groupID string, userID string) error {
	ret := _m.Called(ctx, groupID, userID)

	if len(ret) == 0 {
		panic("no return value specified for RemoveMember")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, groupID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GroupRepository_RemoveMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveMember'
type GroupRepository_RemoveMember_Call struct {
	*mock.Call
}

// RemoveMember is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID string
//   - userID string
func (_e *GroupRepository_Expecter) RemoveMember(ctx interface{}, groupID interface{}, userID interface{}) *GroupRepository_RemoveMember_Call {
	return &GroupRepository_RemoveMember_Call{Call: _e.mock.On("RemoveMember", ctx, groupID, userID)}
}

func (_c *GroupRepository_RemoveMember_Call) Run(run func(ctx context.Context, groupID string, userID string)) *GroupRepository_RemoveMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *GroupRepository_RemoveMember_Call) Return(_a0 error) *GroupRepository_RemoveMember_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *GroupRepository_RemoveMember_Call) RunAndReturn(run func(context.Context, string, string) error) *GroupRepository_RemoveMember_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateGroup provides a mock function with given fields: ctx, group
func (_m *GroupRepository) UpdateGroup(ctx context.Context, group *entity.Group) error {
	ret := _m.Called(ctx, group)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGroup")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *entity.Group) error); ok {
		r0 = rf(ctx, group)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GroupRepository_UpdateGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateGroup'
type GroupRepository_UpdateGroup_Call struct {
	*mock.Call
}

// UpdateGroup is a helper method to define mock.On call
//   - ctx context.Context
//   - group *entity.Group
func (_e *GroupRepository_Expecter) UpdateGroup(ctx interface{}, group interface{}) *GroupRepository_UpdateGroup_Call {
	return &GroupRepository_UpdateGroup_Call{Call: _e.mock.On("UpdateGroup", ctx, group)}
}

func (_c *GroupRepository_UpdateGroup_Call) Run(run func(ctx context.Context, group *entity.Group)) *GroupRepository_UpdateGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*entity.Group))
	})
	return _c
}

func (_c *GroupRepository_UpdateGroup_Call) Return(_a0 error) *GroupRepository_UpdateGroup_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *GroupRepository_UpdateGroup_Call) RunAndReturn(run func(context.Context, *entity.Group) error) *GroupRepository_UpdateGroup_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateGroupInviteCode provides a mock function with given fields: ctx, groupID, code, expireAt
func (_m *GroupRepository) UpdateGroupInviteCode(ctx context.Context, groupID string, code string, expireAt *time.Time) error {
	ret := _m.Called(ctx, groupID, code, expireAt)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGroupInviteCode")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *time.Time) error); ok {
		r0 = rf(ctx, groupID, code, expireAt)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GroupRepository_UpdateGroupInviteCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateGroupInviteCode'
type GroupRepository_UpdateGroupInviteCode_Call struct {
	*mock.Call
}

// UpdateGroupInviteCode is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID string
//   - code string
//   - expireAt *time.Time
func (_e *GroupRepository_Expecter) UpdateGroupInviteCode(ctx interface{}, groupID interface{}, code interface{}, expireAt interface{}) *GroupRepository_UpdateGroupInviteCode_Call {
	return &GroupRepository_UpdateGroupInviteCode_Call{Call: _e.mock.On("UpdateGroupInviteCode", ctx, groupID, code, expireAt)}
}

func (_c *GroupRepository_UpdateGroupInviteCode_Call) Run(run func(ctx context.Context, groupID string, code string, expireAt *time.Time)) *GroupRepository_UpdateGroupInviteCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*time.Time))
	})
	return _c
}

func (_c *GroupRepository_UpdateGroupInviteCode_Call) Return(_a0 error) *GroupRepository_UpdateGroupInviteCode_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *GroupRepository_UpdateGroupInviteCode_Call) RunAndReturn(run func(context.Context, string, string, *time.Time) error) *GroupRepository_UpdateGroupInviteCode_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateMember provides a mock function with given fields: ctx, member
func (_m *GroupRepository) UpdateMember(ctx context.Context, member *entity.GroupMember) error {
	ret := _m.Called(ctx, member)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMember")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *entity.GroupMember) error); ok {
		r0 = rf(ctx, member)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GroupRepository_UpdateMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMember'
type GroupRepository_UpdateMember_Call struct {
	*mock.Call
}

// UpdateMember is a helper method to define mock.On call
//   - ctx context.Context
//   - member *entity.GroupMember
func (_e *GroupRepository_Expecter) UpdateMember(ctx interface{}, member interface{}) *GroupRepository_UpdateMember_Call {
	return &GroupRepository_UpdateMember_Call{Call: _e.mock.On("UpdateMember", ctx, member)}
}

func (_c *GroupRepository_UpdateMember_Call) Run(run func(ctx context.Context, member *entity.GroupMember)) *GroupRepository_UpdateMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*entity.GroupMember))
	})
	return _c
}

func (_c *GroupRepository_UpdateMember_Call) Return(_a0 error) *GroupRepository_UpdateMember_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *GroupRepository_UpdateMember_Call) RunAndReturn(run func(context.Context, *entity.GroupMember) error) *GroupRepository_UpdateMember_Call {
	_c.Call.Return(run)
	return _c
}

// NewGroupRepository creates a new instance of GroupRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGroupRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *GroupRepository {
	mock := &GroupRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
