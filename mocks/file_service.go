// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	context "context"
	io "io"
	entity "oss-backend/internal/model/entity"

	mock "github.com/stretchr/testify/mock"

	multipart "mime/multipart"
)

// FileService is an autogenerated mock type for the FileService type
type FileService struct {
	mock.Mock
}

// CheckFilePermission provides a mock function with given fields: ctx, fileID, userID, requiredAction
func (_m *FileService) CheckFilePermission(ctx context.Context, fileID string, userID string, requiredAction string) (bool, error) {
	ret := _m.Called(ctx, fileID, userID, requiredAction)

	if len(ret) == 0 {
		panic("no return value specified for CheckFilePermission")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (bool, error)); ok {
		return rf(ctx, fileID, userID, requiredAction)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) bool); ok {
		r0 = rf(ctx, fileID, userID, requiredAction)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, fileID, userID, requiredAction)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFolder provides a mock function with given fields: ctx, projectID, userID, path, folderName
func (_m *FileService) CreateFolder(ctx context.Context, projectID string, userID string, path string, folderName string) (*entity.File, error) {
	ret := _m.Called(ctx, projectID, userID, path, folderName)

	if len(ret) == 0 {
		panic("no return value specified for CreateFolder")
	}

	var r0 *entity.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) (*entity.File, error)); ok {
		return rf(ctx, projectID, userID, path, folderName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *entity.File); ok {
		r0 = rf(ctx, projectID, userID, path, folderName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, projectID, userID, path, folderName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateShare provides a mock function with given fields: ctx, fileID, userID, password, expireHours, downloadLimit
func (_m *FileService) CreateShare(ctx context.Context, fileID string, userID string, password string, expireHours int, downloadLimit int) (*entity.FileShare, error) {
	ret := _m.Called(ctx, fileID, userID, password, expireHours, downloadLimit)

	if len(ret) == 0 {
		panic("no return value specified for CreateShare")
	}

	var r0 *entity.FileShare
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, int) (*entity.FileShare, error)); ok {
		return rf(ctx, fileID, userID, password, expireHours, downloadLimit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, int) *entity.FileShare); ok {
		r0 = rf(ctx, fileID, userID, password, expireHours, downloadLimit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.FileShare)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, int, int) error); ok {
		r1 = rf(ctx, fileID, userID, password, expireHours, downloadLimit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFile provides a mock function with given fields: ctx, fileID, userID
func (_m *FileService) DeleteFile(ctx context.Context, fileID string, userID string) error {
	ret := _m.Called(ctx, fileID, userID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, fileID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Download provides a mock function with given fields: ctx, fileID, userID
func (_m *FileService) Download(ctx context.Context, fileID string, userID string) (io.ReadCloser, *entity.File, error) {
	ret := _m.Called(ctx, fileID, userID)

	if len(ret) == 0 {
		panic("no return value specified for Download")
	}

	var r0 io.ReadCloser
	var r1 *entity.File
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (io.ReadCloser, *entity.File, error)); ok {
		return rf(ctx, fileID, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) io.ReadCloser); ok {
		r0 = rf(ctx, fileID, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) *entity.File); ok {
		r1 = rf(ctx, fileID, userID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*entity.File)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string) error); ok {
		r2 = rf(ctx, fileID, userID)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DownloadSharedFile provides a mock function with given fields: ctx, shareCode, password
func (_m *FileService) DownloadSharedFile(ctx context.Context, shareCode string, password string) (io.ReadCloser, *entity.File, error) {
	ret := _m.Called(ctx, shareCode, password)

	if len(ret) == 0 {
		panic("no return value specified for DownloadSharedFile")
	}

	var r0 io.ReadCloser
	var r1 *entity.File
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (io.ReadCloser, *entity.File, error)); ok {
		return rf(ctx, shareCode, password)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) io.ReadCloser); ok {
		r0 = rf(ctx, shareCode, password)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) *entity.File); ok {
		r1 = rf(ctx, shareCode, password)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*entity.File)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string) error); ok {
		r2 = rf(ctx, shareCode, password)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetFileInfo provides a mock function with given fields: ctx, fileID
func (_m *FileService) GetFileInfo(ctx context.Context, fileID string) (*entity.File, error) {
	ret := _m.Called(ctx, fileID)

	if len(ret) == 0 {
		panic("no return value specified for GetFileInfo")
	}

	var r0 *entity.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.File, error)); ok {
		return rf(ctx, fileID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.File); ok {
		r0 = rf(ctx, fileID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, fileID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFileVersion provides a mock function with given fields: ctx, fileID, version
func (_m *FileService) GetFileVersion(ctx context.Context, fileID string, version int) (*entity.FileVersion, error) {
	ret := _m.Called(ctx, fileID, version)

	if len(ret) == 0 {
		panic("no return value specified for GetFileVersion")
	}

	var r0 *entity.FileVersion
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int) (*entity.FileVersion, error)); ok {
		return rf(ctx, fileID, version)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *entity.FileVersion); ok {
		r0 = rf(ctx, fileID, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.FileVersion)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int) error); ok {
		r1 = rf(ctx, fileID, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFileVersions provides a mock function with given fields: ctx, fileID
func (_m *FileService) GetFileVersions(ctx context.Context, fileID string) ([]*entity.FileVersion, error) {
	ret := _m.Called(ctx, fileID)

	if len(ret) == 0 {
		panic("no return value specified for GetFileVersions")
	}

	var r0 []*entity.FileVersion
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*entity.FileVersion, error)); ok {
		return rf(ctx, fileID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*entity.FileVersion); ok {
		r0 = rf(ctx, fileID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.FileVersion)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, fileID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPublicDownloadURL provides a mock function with given fields: ctx, fileID
func (_m *FileService) GetPublicDownloadURL(ctx context.Context, fileID string) (string, error) {
	ret := _m.Called(ctx, fileID)

	if len(ret) == 0 {
		panic("no return value specified for GetPublicDownloadURL")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, fileID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, fileID)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, fileID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetShareInfo provides a mock function with given fields: ctx, shareCode
func (_m *FileService) GetShareInfo(ctx context.Context, shareCode string) (*entity.FileShare, error) {
	ret := _m.Called(ctx, shareCode)

	if len(ret) == 0 {
		panic("no return value specified for GetShareInfo")
	}

	var r0 *entity.FileShare
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.FileShare, error)); ok {
		return rf(ctx, shareCode)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.FileShare); ok {
		r0 = rf(ctx, shareCode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.FileShare)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, shareCode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFiles provides a mock function with given fields: ctx, projectID, path, recursive, page, pageSize
func (_m *FileService) ListFiles(ctx context.Context, projectID string, path string, recursive bool, page int, pageSize int) ([]*entity.File, int64, error) {
	ret := _m.Called(ctx, projectID, path, recursive, page, pageSize)

	if len(ret) == 0 {
		panic("no return value specified for ListFiles")
	}

	var r0 []*entity.File
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, int, int) ([]*entity.File, int64, error)); ok {
		return rf(ctx, projectID, path, recursive, page, pageSize)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, int, int) []*entity.File); ok {
		r0 = rf(ctx, projectID, path, recursive, page, pageSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool, int, int) int64); ok {
		r1 = rf(ctx, projectID, path, recursive, page, pageSize)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool, int, int) error); ok {
		r2 = rf(ctx, projectID, path, recursive, page, pageSize)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RestoreFile provides a mock function with given fields: ctx, fileID, userID
func (_m *FileService) RestoreFile(ctx context.Context, fileID string, userID string) error {
	ret := _m.Called(ctx, fileID, userID)

	if len(ret) == 0 {
		panic("no return value specified for RestoreFile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, fileID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Upload provides a mock function with given fields: ctx, projectID, uploaderID, file, path
func (_m *FileService) Upload(ctx context.Context, projectID string, uploaderID string, file *multipart.FileHeader, path string) (*entity.File, error) {
	ret := _m.Called(ctx, projectID, uploaderID, file, path)

	if len(ret) == 0 {
		panic("no return value specified for Upload")
	}

	var r0 *entity.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *multipart.FileHeader, string) (*entity.File, error)); ok {
		return rf(ctx, projectID, uploaderID, file, path)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *multipart.FileHeader, string) *entity.File); ok {
		r0 = rf(ctx, projectID, uploaderID, file, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *multipart.FileHeader, string) error); ok {
		r1 = rf(ctx, projectID, uploaderID, file, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewFileService creates a new instance of FileService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFileService(t interface {
	mock.TestingT
	Cleanup(func())
}) *FileService {
	mock := &FileService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
