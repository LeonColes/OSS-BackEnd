// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	context "context"
	entity "oss-backend/internal/model/entity"

	mock "github.com/stretchr/testify/mock"
)

// FileRepository is an autogenerated mock type for the FileRepository type
type FileRepository struct {
	mock.Mock
}

// Create provides a mock function with given fields: ctx, file
func (_m *FileRepository) Create(ctx context.Context, file *entity.File) error {
	ret := _m.Called(ctx, file)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *entity.File) error); ok {
		r0 = rf(ctx, file)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateShare provides a mock function with given fields: ctx, share
func (_m *FileRepository) CreateShare(ctx context.Context, share *entity.FileShare) error {
	ret := _m.Called(ctx, share)

	if len(ret) == 0 {
		panic("no return value specified for CreateShare")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *entity.FileShare) error); ok {
		r0 = rf(ctx, share)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateVersion provides a mock function with given fields: ctx, version
func (_m *FileRepository) CreateVersion(ctx context.Context, version *entity.FileVersion) error {
	ret := _m.Called(ctx, version)

	if len(ret) == 0 {
		panic("no return value specified for CreateVersion")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *entity.FileVersion) error); ok {
		r0 = rf(ctx, version)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Delete provides a mock function with given fields: ctx, id
func (_m *FileRepository) Delete(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteShare provides a mock function with given fields: ctx, id
func (_m *FileRepository) DeleteShare(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteShare")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetByHash provides a mock function with given fields: ctx, hash
func (_m *FileRepository) GetByHash(ctx context.Context, hash string) (*entity.File, error) {
	ret := _m.Called(ctx, hash)

	if len(ret) == 0 {
		panic("no return value specified for GetByHash")
	}

	var r0 *entity.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.File, error)); ok {
		return rf(ctx, hash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.File); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByID provides a mock function with given fields: ctx, id
func (_m *FileRepository) GetByID(ctx context.Context, id string) (*entity.File, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 *entity.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.File, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.File); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByPath provides a mock function with given fields: ctx, projectID, path, fileName
func (_m *FileRepository) GetByPath(ctx context.Context, projectID string, path string, fileName string) (*entity.File, error) {
	ret := _m.Called(ctx, projectID, path, fileName)

	if len(ret) == 0 {
		panic("no return value specified for GetByPath")
	}

	var r0 *entity.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (*entity.File, error)); ok {
		return rf(ctx, projectID, path, fileName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *entity.File); ok {
		r0 = rf(ctx, projectID, path, fileName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, projectID, path, fileName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetShareByCode provides a mock function with given fields: ctx, code
func (_m *FileRepository) GetShareByCode(ctx context.Context, code string) (*entity.FileShare, error) {
	ret := _m.Called(ctx, code)

	if len(ret) == 0 {
		panic("no return value specified for GetShareByCode")
	}

	var r0 *entity.FileShare
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.FileShare, error)); ok {
		return rf(ctx, code)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.FileShare); ok {
		r0 = rf(ctx, code)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.FileShare)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, code)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVersionByID provides a mock function with given fields: ctx, fileID, version
func (_m *FileRepository) GetVersionByID(ctx context.Context, fileID string, version int) (*entity.FileVersion, error) {
	ret := _m.Called(ctx, fileID, version)

	if len(ret) == 0 {
		panic("no return value specified for GetVersionByID")
	}

	var r0 *entity.FileVersion
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int) (*entity.FileVersion, error)); ok {
		return rf(ctx, fileID, version)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *entity.FileVersion); ok {
		r0 = rf(ctx, fileID, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.FileVersion)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int) error); ok {
		r1 = rf(ctx, fileID, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVersions provides a mock function with given fields: ctx, fileID
func (_m *FileRepository) GetVersions(ctx context.Context, fileID string) ([]*entity.FileVersion, error) {
	ret := _m.Called(ctx, fileID)

	if len(ret) == 0 {
		panic("no return value specified for GetVersions")
	}

	var r0 []*entity.FileVersion
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*entity.FileVersion, error)); ok {
		return rf(ctx, fileID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*entity.FileVersion); ok {
		r0 = rf(ctx, fileID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.FileVersion)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, fileID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// List provides a mock function with given fields: ctx, projectID, path, recursive, includeDeleted, page, pageSize
func (_m *FileRepository) List(ctx context.Context, projectID string, path string, recursive bool, includeDeleted bool, page int, pageSize int) ([]*entity.File, int64, error) {
	ret := _m.Called(ctx, projectID, path, recursive, includeDeleted, page, pageSize)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 []*entity.File
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, bool, int, int) ([]*entity.File, int64, error)); ok {
		return rf(ctx, projectID, path, recursive, includeDeleted, page, pageSize)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, bool, int, int) []*entity.File); ok {
		r0 = rf(ctx, projectID, path, recursive, includeDeleted, page, pageSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool, bool, int, int) int64); ok {
		r1 = rf(ctx, projectID, path, recursive, includeDeleted, page, pageSize)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, bool, bool, int, int) error); ok {
		r2 = rf(ctx, projectID, path, recursive, includeDeleted, page, pageSize)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ListByIDs provides a mock function with given fields: ctx, ids
func (_m *FileRepository) ListByIDs(ctx context.Context, ids []string) ([]*entity.File, error) {
	ret := _m.Called(ctx, ids)

	if len(ret) == 0 {
		panic("no return value specified for ListByIDs")
	}

	var r0 []*entity.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*entity.File, error)); ok {
		return rf(ctx, ids)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*entity.File); ok {
		r0 = rf(ctx, ids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, ids)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: ctx, file
func (_m *FileRepository) Update(ctx context.Context, file *entity.File) error {
	ret := _m.Called(ctx, file)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *entity.File) error); ok {
		r0 = rf(ctx, file)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateShareDownloadCount provides a mock function with given fields: ctx, shareID
func (_m *FileRepository) UpdateShareDownloadCount(ctx context.Context, shareID string) error {
	ret := _m.Called(ctx, shareID)

	if len(ret) == 0 {
		panic("no return value specified for UpdateShareDownloadCount")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, shareID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewFileRepository creates a new instance of FileRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFileRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *FileRepository {
	mock := &FileRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
